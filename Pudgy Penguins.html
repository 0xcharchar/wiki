<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
        
    <title>Pudgy Penguins</title>

    <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
      div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
      ul.task-list{list-style: none;}
      .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    </style>
      <link rel="stylesheet" href="style.css" />
        </head>

  <body>
    
    
    
    <main>
      <h1 id="Pudgy Penguins">Pudgy Penguins</h1>
      <p><a href="https://etherscan.io/address/0xBd3531dA5CF5857e7CfAA92426877b022e612cf8">Etherscan</a> <a href="https://www.pudgypenguins.io/#/">Site</a></p>
      <h2 id="PudgyPenguins.sol">PudgyPenguins.sol</h2>
      <pre class="solidity"><code>// SPDX-License-Identifier: MIT
      pragma solidity ^0.8.0;

      import &quot;@openzeppelin/contracts/token/ERC721/ERC721.sol&quot;;
      import &quot;@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol&quot;;
      import &quot;@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol&quot;;
      import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;
      import &quot;@openzeppelin/contracts/utils/math/SafeMath.sol&quot;;
      import &quot;@openzeppelin/contracts/utils/Counters.sol&quot;;
      import &quot;./ERC721Pausable.sol&quot;;
      contract PudgyPenguins is ERC721Enumerable, Ownable, ERC721Burnable, ERC721Pausable {
          using SafeMath for uint256;
          using Counters for Counters.Counter;

          Counters.Counter private _tokenIdTracker;

          uint256 public constant MAX_ELEMENTS = 8888;
          uint256 public constant PRICE = 3 * 10**16;
          uint256 public constant MAX_BY_MINT = 20;
          uint256 public constant reveal_timestamp = 1627588800; // Thu Jul 29 2021 20:00:00 GMT+0000
          address public constant creatorAddress = 0x6F84Fa72Ca4554E0eEFcB9032e5A4F1FB41b726C;
          address public constant devAddress = 0xcBCc84766F2950CF867f42D766c43fB2D2Ba3256;
          string public baseTokenURI;

          event CreatePenguin(uint256 indexed id);
          constructor(string memory baseURI) ERC721(&quot;PudgyPenguins&quot;, &quot;PPG&quot;) {
              setBaseURI(baseURI);
              pause(true);
          }

          modifier saleIsOpen {
              require(_totalSupply() &lt;= MAX_ELEMENTS, &quot;Sale end&quot;);
              if (_msgSender() != owner()) {
                  require(!paused(), &quot;Pausable: paused&quot;);
              }
              _;
          }
          function _totalSupply() internal view returns (uint) {
              return _tokenIdTracker.current();
          }
          function totalMint() public view returns (uint256) {
              return _totalSupply();
          }
          function mint(address _to, uint256 _count) public payable saleIsOpen {
              uint256 total = _totalSupply();
              require(total + _count &lt;= MAX_ELEMENTS, &quot;Max limit&quot;);
              require(total &lt;= MAX_ELEMENTS, &quot;Sale end&quot;);
              require(_count &lt;= MAX_BY_MINT, &quot;Exceeds number&quot;);
              require(msg.value &gt;= price(_count), &quot;Value below price&quot;);

              for (uint256 i = 0; i &lt; _count; i++) {
                  _mintAnElement(_to);
              }
          }
          function _mintAnElement(address _to) private {
              uint id = _totalSupply();
              _tokenIdTracker.increment();
              _safeMint(_to, id);
              emit CreatePenguin(id);
          }
          function price(uint256 _count) public pure returns (uint256) {
              return PRICE.mul(_count);
          }

          function _baseURI() internal view virtual override returns (string memory) {
              return baseTokenURI;
          }

          function setBaseURI(string memory baseURI) public onlyOwner {
              baseTokenURI = baseURI;
          }

          function walletOfOwner(address _owner) external view returns (uint256[] memory) {
              uint256 tokenCount = balanceOf(_owner);

              uint256[] memory tokensId = new uint256[](tokenCount);
              for (uint256 i = 0; i &lt; tokenCount; i++) {
                  tokensId[i] = tokenOfOwnerByIndex(_owner, i);
              }

              return tokensId;
          }

          function pause(bool val) public onlyOwner {
              if (val == true) {
                  _pause();
                  return;
              }
              _unpause();
          }

          function withdrawAll() public payable onlyOwner {
              uint256 balance = address(this).balance;
              require(balance &gt; 0);
              _widthdraw(devAddress, balance.mul(35).div(100));
              _widthdraw(creatorAddress, address(this).balance);
          }

          function _widthdraw(address _address, uint256 _amount) private {
              (bool success, ) = _address.call{value: _amount}(&quot;&quot;);
              require(success, &quot;Transfer failed.&quot;);
          }

          function _beforeTokenTransfer(
              address from,
              address to,
              uint256 tokenId
          ) internal virtual override(ERC721, ERC721Enumerable, ERC721Pausable) {
              super._beforeTokenTransfer(from, to, tokenId);
          }

          function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, ERC721Enumerable) returns (bool) {
              return super.supportsInterface(interfaceId);
          }
          
      }</code></pre>
      <h3 id="minting">minting</h3>
      <pre class="solidity"><code>function mint(address _to, uint256 _count) public payable saleIsOpen {
          uint256 total = _totalSupply();

          // make sure the requested mint amount does not exceed penguin limit
          require(total + _count &lt;= MAX_ELEMENTS, &quot;Max limit&quot;);
          
          // make sure there are still penguins to mint
          require(total &lt;= MAX_ELEMENTS, &quot;Sale end&quot;);
          
          // make sure only a limited amount of penguins can be minted
          require(_count &lt;= MAX_BY_MINT, &quot;Exceeds number&quot;);
          
          // finally, make sure the user is paying enough
          require(msg.value &gt;= price(_count), &quot;Value below price&quot;);

          // for loop is safe because there is a limit to the number of loops (MAX_BY_MINT)
          for (uint256 i = 0; i &lt; _count; i++) {
              _mintAnElement(_to);
          }
      }

      /*
       * interesting token generation:
         * pull the current value, use it as the id
         * increment value
       * this seems backwards in my simpleton brain but oh well, it still works
      */
      function _mintAnElement(address _to) private {
          uint id = _totalSupply();
          _tokenIdTracker.increment();
          _safeMint(_to, id);
          emit CreatePenguin(id);
      }</code></pre>
      <h3 id="token owner &#39;wallet&#39;">token owner 'wallet'</h3>
      <p>Finds all the tokens for a given address. This reduces calls into the contract to do the same thing.</p>
      <pre class="solidity"><code>function walletOfOwner(address _owner) external view returns (uint256[] memory) {
          uint256 tokenCount = balanceOf(_owner);

          uint256[] memory tokensId = new uint256[](tokenCount);
          for (uint256 i = 0; i &lt; tokenCount; i++) {
              tokensId[i] = tokenOfOwnerByIndex(_owner, i);
          }

          return tokensId;
      }</code></pre>
      <p>To do with javascrpit/ethers (assuming contract implements <code>IERC721Enumerable</code>):</p>
      <pre class="javascript"><code>async function walletOfOwner (contract, owner) {
        const ownerTotal = await contract.balanceOf(owner)
        
        return Promise.all(
          (new Array(ownerTotal)).fill(null)
            .map((_, idx) =&gt; contract.tokenOfOwnerByIndex(owner, idx))
        )
      }</code></pre>
      <p><a href="https://docs.openzeppelin.com/contracts/4.x/api/token/erc721#IERC721Enumerable">https://docs.openzeppelin.com/contracts/4.x/api/token/erc721#IERC721Enumerable</a></p>
      <h3 id="withdraw ether">withdraw ether</h3>
      <p>Withdrawing ETH gives a cut to the developer and then the rest goes to the 'creator'. Kind of neat.</p>
      <pre class="solidity"><code>function withdrawAll() public payable onlyOwner {
          uint256 balance = address(this).balance;
          require(balance &gt; 0);
          _widthdraw(devAddress, balance.mul(35).div(100));
          _widthdraw(creatorAddress, address(this).balance);
      }

      function _widthdraw(address _address, uint256 _amount) private {
          // the `call` function is used so that funds can be withdrawn to a smart contract and avoid gas problems
          // _I think_
          (bool success, ) = _address.call{value: _amount}(&quot;&quot;);
          require(success, &quot;Transfer failed.&quot;);
      }</code></pre>
    </main>

      </body>
</html>
