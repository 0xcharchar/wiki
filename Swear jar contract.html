<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
        
    <title>Swear jar contract</title>

    <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
      div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
      ul.task-list{list-style: none;}
      pre > code.sourceCode { white-space: pre; position: relative; }
      pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
      pre > code.sourceCode > span:empty { height: 1.2em; }
      .sourceCode { overflow: visible; }
      code.sourceCode > span { color: inherit; text-decoration: inherit; }
      div.sourceCode { margin: 1em 0; }
      pre.sourceCode { margin: 0; }
      @media screen {
      div.sourceCode { overflow: auto; }
      }
      @media print {
      pre > code.sourceCode { white-space: pre-wrap; }
      pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
      }
      pre.numberSource code
        { counter-reset: source-line 0; }
      pre.numberSource code > span
        { position: relative; left: -4em; counter-increment: source-line; }
      pre.numberSource code > span > a:first-child::before
        { content: counter(source-line);
          position: relative; left: -1em; text-align: right; vertical-align: baseline;
          border: none; display: inline-block;
          -webkit-touch-callout: none; -webkit-user-select: none;
          -khtml-user-select: none; -moz-user-select: none;
          -ms-user-select: none; user-select: none;
          padding: 0 4px; width: 4em;
          color: #aaaaaa;
        }
      pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
      div.sourceCode
        {   }
      @media screen {
      pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
      }
      code span.al { color: #ff0000; font-weight: bold; } /* Alert */
      code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
      code span.at { color: #7d9029; } /* Attribute */
      code span.bn { color: #40a070; } /* BaseN */
      code span.bu { } /* BuiltIn */
      code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
      code span.ch { color: #4070a0; } /* Char */
      code span.cn { color: #880000; } /* Constant */
      code span.co { color: #60a0b0; font-style: italic; } /* Comment */
      code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
      code span.do { color: #ba2121; font-style: italic; } /* Documentation */
      code span.dt { color: #902000; } /* DataType */
      code span.dv { color: #40a070; } /* DecVal */
      code span.er { color: #ff0000; font-weight: bold; } /* Error */
      code span.ex { } /* Extension */
      code span.fl { color: #40a070; } /* Float */
      code span.fu { color: #06287e; } /* Function */
      code span.im { } /* Import */
      code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
      code span.kw { color: #007020; font-weight: bold; } /* Keyword */
      code span.op { color: #666666; } /* Operator */
      code span.ot { color: #007020; } /* Other */
      code span.pp { color: #bc7a00; } /* Preprocessor */
      code span.sc { color: #4070a0; } /* SpecialChar */
      code span.ss { color: #bb6688; } /* SpecialString */
      code span.st { color: #4070a0; } /* String */
      code span.va { color: #19177c; } /* Variable */
      code span.vs { color: #4070a0; } /* VerbatimString */
      code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
      .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    </style>
      <link rel="stylesheet" href="/wiki/style.css" />
        </head>

  <body>
    
    
    
    <main>
      <h1 id="Swear Jar">Swear Jar</h1>
      <p>gm/gn/ge/ga wagmi</p>
      <p>The Swear Jar is a smart contract, oracle, and bot to help users pay for their foul language.</p>
      <h2 id="You what now">You what now</h2>
      <p>So it turns out my day job is good for exactly one thing: discussing how much I swear and how I need to start paying for it.</p>
      <p>I dunno, fuck them.</p>
      <p>Let's go ahead and create a system whereby a user on Twitter swears, the user is confirmed to have an ENS domain and a wallet, and then a new token is made for minting by that user so that they can keep their swear words as a badge of honor. Or something. I'd say we should charge a fee but the fucking gas prices these days...</p>
      <h2 id="butt how">butt how</h2>
      <p>Take a look at this handy diagram</p>
      <p><img src="./swear-jar-contract.png" alt="" /></p>
      <p>There are five players in this game:</p>
      <ul>
      <li>The fucking user</li>
      <li>The fucking Twitter bot</li>
      <li>The fucking oracle contract</li>
      <li>The fucking swear jar contract</li>
      <li>And ENS</li>
      </ul>
      <p>The basic flow goes:</p>
      <ul>
      <li>Bot watches Twatter for swears</li>
      <li>User make swear =O</li>
      <li>Bot checks if user has a valid ENS domain and wallet</li>
      <li>Bot tattles on user to oracle</li>
      <li>Oracle informs swear jar with: Twitter message and wallet addr</li>
      <li>Bot waits for event from swear jar then replies to user with minting link</li>
      <li>User fucking ignores because why in the fuck would they mint their own swear words. In this environment. With these fees.</li>
      </ul>
      <p>Guess what, friendo, I've done the research. I have calculated the numbers. I have read the analytics. Let me break down the entire fool proof plan that will make you famous and broke for implementing a goddamned stupid idea.</p>
      <h2 id="The bot">The bot</h2>
      <p>Aunt Shirley bot (yes, you have to use this name) has one job:</p>
      <ol>
      <li>monitor potential swearers who probably have a Ethereum wallet</li>
      <li>catch those dirty swears and rat on the user</li>
      <li>remind the user they need to pay up or risk ostracization from CT</li>
      </ol>
      <p>Step one should be mostly easy:</p>
      <ul>
      <li>with the dev account you already setup, you're going to use a <a href="https://developer.twitter.com/en/docs/twitter-api/tweets/filtered-stream/introduction">Filtered Stream</a></li>
      <li>add a rule that looks like this
      <div class="sourceCode" id="cb1"><pre class="sourceCode json"><code class="sourceCode json"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span> <span class="dt">&quot;value&quot;</span><span class="fu">:</span> <span class="st">&quot;-is:retweet bio_name:.eth&quot;</span><span class="fu">,</span> <span class="dt">&quot;tag&quot;</span><span class="fu">:</span> <span class="st">&quot;foul mouthed children&quot;</span> <span class="fu">}</span></span></code></pre></div></li>
      </ul>
      <p>Now you have a stream of tweets, presumably from people with an ENS domain.</p>
      <p>Step two is filtering the stream so start by getting the right fields:</p>
      <pre><code>https://api.twitter.com/2/tweets/search/stream?tweet.fields=id,text&amp;expansions=author_id&amp;user.fields=username</code></pre>
      <p>With that stream, you can parse the <code>text</code> for swears using <code>isProfane</code> from the <a href="https://github.com/web-mech/badwords">badwords package</a>. Then, take the <code>username</code> and parse out the potential ENS domain and confirm validity with ENS. Here are some examples:</p>
      <div class="sourceCode" id="cb3"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> sampleUsernames <span class="op">=</span> [<span class="st">&#39;vitalik.eth&#39;</span><span class="op">,</span> <span class="st">&#39;‚ü† toast.eth &#39;</span><span class="op">,</span> <span class="st">&#39;Farokh.eth&#39;</span><span class="op">,</span> <span class="st">&#39;ETHDenver&#39;</span><span class="op">,</span> <span class="st">&#39;Sriram Krishnan - sriramk.eth&#39;</span>]</span>
      <span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
      <span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> clean <span class="op">=</span> sampleUsernames</span>
      <span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="fu">map</span>(user <span class="kw">=&gt;</span> user<span class="op">.</span><span class="fu">match</span>(<span class="ss">/</span><span class="sc">[a-zA-Z0-9]*\.</span><span class="ss">eth/</span>))</span>
      <span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="fu">filter</span>(user <span class="kw">=&gt;</span> user <span class="op">!=</span> <span class="kw">null</span>)</span>
      <span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="fu">map</span>(([ens]) <span class="kw">=&gt;</span> ens<span class="op">.</span><span class="fu">toLowerCase</span>())</span>
      <span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
      <span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(clean)</span>
      <span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="co">// [ &#39;vitalik.eth&#39;, &#39;toast.eth&#39;, &#39;farokh.eth&#39;, &#39;sriramk.eth&#39; ]</span></span></code></pre></div>
      <p>With your clean names, check ENS to make sure those are valid domains and have associated wallets. Should be a straightforward process with ethers: <a href="https://docs.ethers.io/v5/api/providers/provider/#Provider-ResolveName">https://docs.ethers.io/v5/api/providers/provider/#Provider-ResolveName</a></p>
      <p>Assuming everything has gone well, you now have two important pieces of data:</p>
      <ul>
      <li>users wallet address</li>
      <li>their tweet url (theres an id in those results, figure it out)</li>
      </ul>
      <p>This data can be used when contacting T H E O R A C L E.</p>
      <p>The final bit of work Aunt Shirley needs to do is listen for new tokens in the swear jar. Now, if Aunt Shirley is also the oracle, this will be easy. Just wait for the transaction to complete and grab the event out of the result. If you use a separate oracle, you need a long poll on the event log from the swear jar. Once the event happens, Aunty can reply to the offensive and profane tweet and demand compensation.</p>
      <h2 id="The oracle">The oracle</h2>
      <p>This could be real simple or real hard. Either you use a fancy oracle or your shitty project has faith in Aunt Shirley's ability to post some data to a contract. Up to you.</p>
      <p>Taking the simplest approach:</p>
      <ul>
      <li>strap a wallet private key to Aunt Shirley</li>
      <li>when Aunt Shirley has confirmed the data, it sends a message to your contract to prepare a new token</li>
      </ul>
      <p>Boom, done.</p>
      <h2 id="The contract">The contract</h2>
      <p>This is the best thing ever.</p>
      <ol>
      <li>Import openzepplin ERC721 and AccessControl contracts</li>
      <li>Create a GENERATOR_ROLE (this will be your oracle) and a DEFAULT_ADMIN_ROLE (this will be you)</li>
      <li>You probably need the following functions:
      <pre class="solidity"><code>event TokenPrepared (uint256 tokenId, address profanePerson);

      modifier isWhitelisted (address sender, unint256 tokenId) {
        require(tokenList[tokenId] != address(0));
        require(tokenList[tokenId] == sender);
        _;
      }

      function newToken (address allowed, bytes32 tweetUrl) external onlyRole(GENERATOR_ROLE) returns (uint256 tokenId);
      function mint (uint256 tokenId) external isWhitelisted(msg.sender, tokenId);
      // if you make mint payable, a withdrawl function might be nice</code></pre></li>
      </ol>
      <p>Or you could get a lazy-minting nft contract and make up for the deficencies with a minting dapp. Would be cheaper for you that way. A lazy-minting contract would require a change in how the bot listens for token prep and contacts the swearer though.</p>
      <h2 id="Wrapping it up">Wrapping it up</h2>
      <p>I doubt I'll ever get around to actually building this but if you, dearest fucking reader, do build this, I would love to see it.</p>
    </main>

    <footer>
      <p>
      Unless otherwise noted on the page, text is <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> and original code samples are under  <a href="https://choosealicense.com/licenses/unlicense/">Unlicense</a>.
      </p>
    </footer>
  </body>
</html>
